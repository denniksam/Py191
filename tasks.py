# Асинхронное программирование
import asyncio   # инструменты запуска и управления асинхр. задачами
import time      # вывод времени

# Отмена задач: объект-задача имеет метод .cancel, его вызов создает в функции задачи
# исключение, которое ее "разрушает". Рекомендуется все тело асинх ф-ций помещать в try
async def get_cancellable( timeout:float, txt:str ) :
  try :
    await asyncio.sleep( timeout )
    return txt 
  except asyncio.CancelledError :
    return "Cancelled"

async def main6() :             
  task2 = asyncio.create_task(  
    get_cancellable( 2, "Task2" ) )
  task1 = asyncio.create_task(  
    get_cancellable( 1, "Task1" ) ) 
  print( time.strftime( "%X" ), "Tasks started" )
  txt = await task1
  print( time.strftime( "%X" ), txt )
  if txt == 'Task1' :                      # Пример условной отмены задачи
    task2.cancel()                         #           
  txt = await task2                        # await раньше 2 сек получает возврат "Cancelled"
  print( time.strftime( "%X" ), txt )

# Д.З. В CGI реализовать асинхронное подключение к БД, реорганизовать код /auth (*/items)
# для работы в асинх-режиме: сначала запуск подключения, потом анализ заголовков, ожидание БД

async def get_timeout( timeout:float, txt:str ) :
  await asyncio.sleep( timeout )
  return txt 

async def main5() :                   # Демонстрация возврата данных из задач
  print( time.strftime( "%X" ) )      # О планировании асинхронных функций (алгоритмов)
  task2 = asyncio.create_task(        #  задачи оцениваем по длительности (task2 дольше task1)
    get_timeout( 2, "Task2" ) )       #  начинаем с самой долгой задачи (даже если
  task1 = asyncio.create_task(        #   первой должна выполниться более короткая)
    get_timeout( 1, "Task1" ) )       #  затем организовываем более короткую (долгая уже работает)
  print( "Tasks started" )            #  перед ожиданием делаем то, что не требует результата от задач
  txt = await task1                   #  короткая нужна раньше - ожидаем ее
  print( txt )                        #  обрабатываем рез-ты короткой задачи (долгая все еще работает)
  print( await task2 )                #  ожидание долгой задачи - после того, как все
  print( "Tasks finished" )           #   зависит от ее рез-тов
  print( time.strftime( "%X" ) )      # 
# например, в авторизации используются действия: извлечение заголовков, проверка, декодирование
# подключение к БД, проверка логина-пароля, ответ
# как переставить задачи для оптимальной работы? Запускаем подключение к БД, заголовки,
# проверка, декодирование, Ожидание БД - проверка
# 2. заголовки - тело - БД --> запуск БД, запуск тела, заголовки, рез-т тела, рез-т БД


async def print_timeout( timeout:float, txt:str ) :
  await asyncio.sleep( timeout )
  print( txt )

async def main3() :                   # print_timeout( 2, "Task1" ) --> Task
  task1 = asyncio.create_task(        # asyncio.create_task - асинхр запуск Task
    print_timeout( 2, "Task1" ) )     #  и сохранение ссылки на объект Task
  task2 = asyncio.create_task(        # второй запуск - не ждет окончания 1
    print_timeout( 1, "Task2" ) )     #  запускается и сохраняется ссылка
  print( "Tasks started" )            # вывод - раньше всех
  await task1                         # блокировка - ожидание task1
  await task2                         # ожидание task2 (можно убрать, т.к. task1 дольше)
  print( "Tasks finished" )           # эта надпись выводится последней


async def main4() :                   # Неоптимальный пример - фактически синхронное
  print( "Tasks started" )            #  выполнение функций
  await print_timeout( 2, "Task1" )   # ~ await сразу с вызовом - отказ от асинхронности
  await print_timeout( 1, "Task2" )   # 
  print( "Tasks finished" )           # 
  

async def main2() :                   #  
  await asyncio.sleep( 2 )            # await - блокирование до окончания вызова 
  print( "Async 2 demo" )             # вывод будет после 2 сек ожидания
        
async def main1() :                   # async - функция возвращает объект Task
  print( "Async demo" )               # 
                                      # 
if __name__ == "__main__" :           # main1() - это не запуск, это создание Task
  # asyncio.run( main2() )            # asyncio.run - запуск созданного Task
  # asyncio.run( main1() )            # синхронный запуск (с ожиданием)
  asyncio.run( main6() ) 


'''
Терминология
 - асинхронность - возможность выполнять код параллельно (
     полностью или имитационно одновременно) - собирательный термин
     для всех видов одновременных/параллельных выполнений:
      сетевые (network/grid), много-процессные, много-поточные и т.п.
    синоним - coroutines (совместная работа / попутчики)
 - многопоточность - разновидность реализации асинхронности
     использованием системных ресурсов "потоки" (если они есть в ОС)
 - многозадачность - --//-- с использованием объектов уровня
     языка программирования - задач (Task/Promise/Future)
 - синхронизация - создание "участков" на которых невозможна
     одновременная работа нескольких алгоритмов

Сравнение многопоточности и многозадачности (общее/разное)
+ оба - реализация асинхронности
- поток принимает функцию типа   void fun(ref object)
  задача - любую функцию (любой возврат, любые аргументы)
- поток может иметь приоритет такой же или даже выше чем основной
    значит продолжить работу после окончания родительского потока
  задачи - обычно фоновые, зависимые от главного потока (его
    окончание также прекращает задачи). В интерпретируемых языках
    задачи могут вообще не быть связанными с потоками
- если участников много, то все потоки - стартуют и работают ||
    а задачи могут иметь ограничение на кол-во одновременно активных

'''